# Claude.md — AIエディター統合指示書

## プロジェクト情報
- プロジェクト名：AI駆動開発プロジェクトテンプレート
- 主要技術スタック：
  - Next.js 14.0.4 (App Router)
  - React 18.2.0
  - TypeScript 5.3.3
  - Tailwind CSS 3.4.0
  - Supabase 2.38.5 (認証・データベース)
  - Vercel (デプロイ)
- 開発環境：Node.js 18以上

## 初期化指示
ユーザーから以下のような指示を受けた場合：
```
このプロジェクトテンプレートを使って「[作りたいもの]」を開発します。
まず全てのドキュメントを読み込んで、プロジェクトを初期化してください。
```

追加オプション：
- GitHubでバージョン管理したい場合は「GitHubも設定して」と追加
- Dockerを使いたい場合は「Dockerも設定して」と追加

## コーディング規約
- 命名規則：
  - ファイル名：kebab-case（例：user-profile.tsx）
  - コンポーネント：PascalCase（例：UserProfile）
  - 変数・関数：camelCase（例：getUserData）
  - 型定義：PascalCase（例：UserData）
- ディレクトリ構造：
  - src/app/ - App Router用ページ
  - src/components/ - 再利用可能コンポーネント
  - src/lib/ - ユーティリティ・設定
  - src/utils/ - ヘルパー関数
- コメント規約：
  - JSDocを使用
  - 複雑なロジックには日本語コメント

## 開発スケジュール管理（最重要）

### DEVELOPMENT_SCHEDULE.mdの自動更新
AIは開発を進める際、必ず以下を実行する：

1. **作業開始時**
   - DEVELOPMENT_SCHEDULE.mdを確認
   - 現在のTODOリストを把握
   - 優先順位に従って作業を選択

2. **機能追加・変更時**
   - 新機能の追加 → TODOリストとマイルストーンを更新
   - 機能の削除 → 変更履歴に記録
   - 仕様変更 → 変更内容を詳細に記録

3. **作業完了時**
   - 完了したタスクにチェック
   - 進捗率を自動計算・更新
   - 次の作業を明確化

### スケジュール更新のタイミング
- 新しい要望を受けた時
- 機能の優先順位が変わった時
- 予定していた機能が不要になった時
- 新しいアイデアが出た時
- エラーや問題が発生した時

## Git自動化ルール（最重要）

### 完全自動化の原則
**ユーザーがGit操作を意識する必要は一切ありません。**
AIが以下のタイミングで自動的にGit操作を実行します。

### 自動コミットの詳細タイミング

1. **即座にコミット（5分以内）**
   - 新規ファイルの作成
   - 重要な機能の実装完了
   - バグ修正の完了
   - 設定ファイルの変更
   - DEVELOPMENT_SCHEDULE.mdの更新

2. **定期コミット（30分ごと）**
   - 作業が30分継続したら自動コミット
   - コミットメッセージ例：「作業中の進捗を保存」

3. **区切りコミット**
   - ユーザーが「ありがとう」「OK」など肯定的な返答をした時
   - ユーザーが新しい機能を要望した時（現在の作業を保存）
   - エラーが解決した時

### ブランチ自動管理

1. **ブランチ作成タイミング**
   ```
   自動判断基準：
   - 新機能の開発 → feature/機能名
   - バグ修正 → fix/問題の内容
   - デザイン変更 → design/変更内容
   - 実験的な変更 → experiment/内容
   ```

2. **ブランチ命名規則**
   ```
   feature/user-auth     # ユーザー認証機能
   fix/login-error      # ログインエラー修正
   design/dark-mode     # ダークモード対応
   ```

3. **自動マージ**
   - 機能が完成したら自動的にmainにマージ
   - コンフリクトがある場合はユーザーに確認

### プッシュについて
- **基本的にはローカルコミットのみ**
- GitHubが設定されている場合のみ、以下のタイミングでプッシュ：
  - 1日の作業終了時
  - 重要な機能の完成時
  - ユーザーが明示的に要求した時

### コミットメッセージの自動生成
```
# 形式
[カテゴリ] 具体的な変更内容

# 例
[機能追加] ユーザー認証機能を実装
[バグ修正] ログイン時のエラーを解消
[デザイン] ヘッダーのレイアウトを改善
[設定] ESLintの設定を追加
[ドキュメント] READMEを更新
[リファクタ] コンポーネントの構造を整理
```

### AI自動コミットルール
1. **機能実装後は必ずコミット**
   - 新機能追加完了時
   - バグ修正完了時
   - 設定ファイル変更時
   - 定期的な進捗保存（30分〜1時間ごと）

2. **ブランチ戦略**
   - 新機能開発時は feature/機能名 ブランチを自動作成
   - バグ修正時は fix/修正内容 ブランチを自動作成
   - 完了後は自動でmainブランチにマージ

3. **コミットメッセージ**
   - 日本語で分かりやすく記述
   - 例：「TODOリスト機能を追加」「ログイン画面のデザインを改善」

4. **自動実行タイミング**
   - ユーザーが「次は何をしますか？」と聞いた時
   - 一区切りついた時点
   - エラー修正後

5. **AIからの能動的提案**
   ユーザーが大きな変更を指示した場合、AIから以下を提案する：
   - 「大きな変更の前に、現在の進捗をコミットしましょうか？」
   - 「新機能開発なので、新しいブランチを作成しますか？」
   - 「複数の変更があるので、段階的にコミットしていきましょうか？」

### 能動的提案の具体例

#### 大きな変更指示を受けた場合
```
ユーザー: 「TODOリストのデザインを全部変えて、カレンダー機能も追加してください」

AI: 「大きな変更になりますね。安全のため以下を提案します：
1. まず現在の進捗をコミットしましょうか？
2. 新機能用のブランチを作成しますか？
3. デザイン変更とカレンダー機能を別々に実装しますか？

どのように進めますか？」
```

#### 複数ファイル変更の場合
```
ユーザー: 「認証システムを追加して、全ページに適用してください」

AI: 「認証システムは重要な機能ですね。以下の手順で安全に実装します：
1. feature/auth ブランチを作成
2. 段階的に実装（ログイン→ページ保護→テスト）
3. 各段階でコミット

この進め方でよろしいですか？」
```

### Git操作実行例
```bash
# AIが自動で以下を実行：
git checkout -b feature/todo-list
git add .
git commit -m "TODOリスト機能を追加"
git checkout main
git merge feature/todo-list
git push origin main
```

### GitHub初期設定
GitHubで空のリポジトリを作成する際の設定：
- Repository name: 任意の名前
- Public/Private: どちらでもOK
- Add a README file: ❌ チェックしない！
- Add .gitignore: ❌ None を選択！
- Choose a license: ❌ None を選択！

### 日常的なGit操作の指示例
```
朝：「GitHubから最新の状態を取得してください」
作業中：「今の変更を保存してください。コミットメッセージは『○○』で」
夜：「今日の作業をGitHubにアップロードしてください」
```

### よくあるGitHubエラーと対処
- **rejected エラー**: リモートとローカルの不整合 → `git pull --rebase`
- **Permission denied**: 認証設定の問題 → アクセストークン確認
- **コンフリクト**: ファイルの衝突 → 手動マージまたはどちらか選択

## よく使うコマンド
```bash
# 開発サーバー起動
npm run dev

# 型チェック
npm run typecheck

# リント実行
npm run lint

# ビルド
npm run build

# 本番環境起動
npm run start
```

## Vercel & Supabase 設定手順

### Vercelデプロイ手順
1. Vercel CLIインストール：`npm i -g vercel`
2. プロジェクトを初期化：`vercel`
3. 環境変数を設定：`vercel env add`

### Supabase設定手順
1. https://supabase.com でプロジェクト作成
2. Project Settings > API からURL・KEYを取得
3. .env.localファイルを作成して設定
4. 認証設定：Authentication > Settings で設定

## 進捗可視化ルール

### 基本方針
非エンジニアが開発状況を把握しやすいよう、進捗を自動で記録・表示する。

### 自動更新タイミング
1. **機能完成時**
   - 完了タスクリストに追加
   - 進捗率を自動計算・更新
   
2. **新しい作業開始時**
   - 進行中タスクに追加
   - 開始時刻を記録

3. **一日の終わり**
   - 「今日の作業記録」を自動生成
   - 明日の予定を提案

### 進捗記録の項目
```
### 📁 ファイル統計
- 作成済みファイル数: XX個
- 変更回数: XX回
- 最大ファイルサイズ: XXX KB
- 使用言語: TypeScript, React, CSS

### 🔧 機能統計
- 実装済み機能: [リスト]
- テスト済み機能: [リスト]
- 保護対象機能: [リスト]

### ⏱️ 時間統計
- 推定開発時間: XX時間
- 実際の開発時間: XX時間
- 平均セッション時間: XX分

### 🎯 マイルストーン
- 達成済み: [リスト]
- 次の目標: [内容]
- 改善提案: [リスト]
```

### ユーザーへの報告例
```
「TODOリスト機能が完成しました！🎉
📊 現在の進捗: 40% (2/5 機能完了)
✅ 今日完了: ログイン機能、TODOリスト機能
🎯 次回予定: デザイン改善」
```

## エラー解説ルール

### 基本方針
エラーが発生した際は、非エンジニアにも理解できるよう丁寧に解説する。

### エラーレベルの判定
```
🟢 軽微なエラー：
- タイポ（文字の間違い）
- 軽微な文法エラー
- 対応: AIが自動修正

🟡 中程度のエラー：
- ファイルパスの問題
- 設定の不備
- 対応: AIが段階的に解決

🔴 重大なエラー：
- システム環境の問題
- 大規模な設計変更が必要
- 対応: AIが詳細な解決プランを提示
```

### よくあるエラーと対処法
- **File not found**: ファイル名やパスの間違い → 正しいパスを確認
- **Permission denied**: アクセス権限の問題 → 権限を付与
- **Syntax Error**: コードの書き方の間違い → 文法を修正
- **Reference Error**: 存在しない変数や関数を参照 → 定義を追加
- **Connection Error**: ネットワーク接続の問題 → 接続を確認
- **Timeout**: 処理時間超過 → 処理を最適化

### 分かりやすい解説テンプレート
```
「○○エラーが発生しました。

🔍 何が起きているか: [原因を日本語で説明]
🛠️ 解決方法: [具体的な手順]
⏱️ 解決時間: 約○分程度

一緒に解決していきましょう！」
```

### 専門用語の扱い
- 英語のエラーメッセージは必ず日本語で解説
- 専門用語は簡単な言葉に置き換え
- 「つまり○○ということです」で補足

### 予防策の提案
- エラー解決後は予防方法も伝える
- 「今度から○○することで防げます」

## バックアップ・復旧ルール

### 基本方針
非エンジニアが安心して開発できるよう、重要なタイミングで自動バックアップを実行する。

### バックアップの保存先
```
project-root/
├── .backups/
│   ├── daily/          # 日次バックアップ
│   ├── before-major/   # 重要変更前
│   └── snapshots/      # スナップショット
```

### 自動バックアップタイミング
1. **重要変更前の必須バックアップ**
   - 大きな機能追加・変更前
   - デザイン全体変更前
   - データベース変更前
   - 複数ファイル同時変更前

2. **定期バックアップ**
   - 1日1回（作業終了時）
   - 重要機能完成時
   - ユーザー要求時

3. **緊急バックアップ**
   - エラー発生直前の正常状態
   - 重大な問題発生前

### バックアップ保持期間
- GitHubを使用：無制限
- ローカルのみ：1ヶ月分が目安

### 復旧支援
1. **簡単な復旧指示**
   ```
   ユーザー: 「2時間前に戻してください」
   AI: 「2時間前のバックアップから復旧します。以下の変更が取り消されます：[詳細]」
   ```

2. **復旧前の確認項目**
   - 復旧ポイントの明示
   - 失われる変更の具体的リスト
   - 残る機能・失われる機能の明示
   - 復旧時間の目安（通常5-10分、最大30分）

## 完成部分の保護ルール（重要）

### 基本方針
ユーザーが「これで完成」「これは変更しないで」と明示した部分は絶対に変更しない。

### 保護対象の識別方法
1. **明示的な保護指示**
   - 「この機能はもう完成なので変更しないでください」
   - 「このデザインで確定です」
   - 「この部分は触らないで」

2. **保護マーク（HTML/JSX）**
   ```html
   <!-- PROTECTED: ユーザー確定済み - 変更禁止 -->
   <header class="main-header">
     <!-- 確定したヘッダーデザイン -->
   </header>
   <!-- /PROTECTED -->
   ```

3. **保護マーク（JavaScript/TypeScript）**
   ```javascript
   // PROTECTED: ユーザー確定済み - 変更禁止
   function loginUser(credentials) {
     // 完成したログイン機能
   }
   // /PROTECTED
   ```

### 保護対象の記録フォーマット
```
### 完成機能
- ログイン機能（src/components/Auth/Login.jsx）- 2024/XX/XX確定
- TODOリスト機能（src/components/Todo/）- 2024/XX/XX確定

### 確定デザイン
- ヘッダーデザイン（src/components/Header.jsx）- 2024/XX/XX確定
- ダッシュボードレイアウト（src/pages/Dashboard.jsx）- 2024/XX/XX確定

### 保護ファイル
- config/database.js - 設定完了
- public/logo.png - 確定ロゴ
```

### AI動作ルール
1. **変更前の確認必須**
   - 既存コードを変更する前に必ず「この部分を変更してもよろしいですか？」と確認
   - 保護マークがある部分は絶対に変更しない

2. **新機能追加時**
   - 既存の完成機能に影響しない方法で実装
   - 必要なら新しいファイルやコンポーネントを作成

3. **デザイン変更時**
   - 確定済みのレイアウトやスタイルは維持
   - 新しいページのみ変更対象とする

### 実行例
```
AI: 「ログイン機能を改善したいのですが、現在のログイン画面のデザインを変更してもよろしいですか？それとも新しい機能として追加しますか？」

ユーザー: 「今のデザインは気に入っているので変更しないで」

AI: 「承知しました。現在のデザインは保護対象として記録し、機能強化は内部処理のみ変更します」
```

### 保護解除ルール
保護対象を変更したい場合は、以下の手順で解除する：

1. **明示的な解除指示**
   ```
   「ログイン画面の保護を解除して、デザインを変更してください」
   「TODOリスト機能の保護を外して、新しい機能を追加してください」
   ```

2. **一時的な変更許可**
   ```
   「ヘッダーデザインを一時的に変更したいです。完了したら再度保護してください」
   ```

3. **AIの確認プロセス**
   ```
   AI: 「保護対象の○○機能を変更されますか？これまでの内容は失われる可能性があります」
   ユーザー: 「はい、変更してください」
   AI: 「承知しました。保護を解除して変更を開始します」
   ```

## 開発ツール導入時期
- レベル1：最初はシンプルに（AIエディター＋テンプレートのみ）
- レベル2：バージョン管理を追加（1週間後）
- レベル3：環境構築を自動化（1ヶ月後）
- レベル4：自動公開を設定（慣れてきたら）

## 注意事項
- Git操作は必ずユーザーに説明してから実行
- コミット前に変更内容を簡潔に報告
- エラーが発生した場合は分かりやすく解説
- 大きな変更指示を受けた場合は必ず事前にGit提案を行う
- ユーザーが複数の機能を同時に指示した場合は分割を提案
- 進捗状況は視覚的に分かりやすく報告
- 重要な変更前は必ずバックアップを提案・実行する

## 禁止事項
- Gitの複雑なコマンドをユーザーに要求する
- コミットなしで大きな変更を重ねる
- ブランチ切り替えをユーザーに任せる
- 保護マークのあるコードを変更する
- ユーザーの明示的な確認なしに既存の完成機能を変更する
- 専門用語を日本語解説なしで使用する
- エラーメッセージを英語のまま表示する